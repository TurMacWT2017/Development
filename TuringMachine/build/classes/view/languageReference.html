<!DOCTYPE html">
<html>
    <head>
    <title>Turing Machine Language Reference</title>
    <style type="text/css">
    a {
        color: #0000aa;
        background-color: #ffffff;
    }
    .image {
        max-width: 97%;
        height: auto;
    }

    img {
        border: 0;
    }
    :visited {
        color: #000077;
        background-color: #ffffff;
    }
    body {
        color: #000000;
        background-color: #ffffff;
        margin: 50px 50px 50px 50px;
    }
    h1 {
        text-align: center;
        color: #ba2326;
        background-color: #ffffff;
    }

    p {
        text-align: justify;
        font-size: 14px;
    }
    code, pre {
        color: #050690;
        background-color: #ffffff;
        font-size: 14px;
        font-weight: bold;
    }
    .copyleft {
        text-align: center;
        font-size: small;
    }
    .buttons {
        margin-left: auto;
        margin-right: auto;
    }
    comment {
        color: #b7b7b7;
        background-color: #ffffff;
        font-size: 14px;
        font-weight: bold;
    }
    .list {
        color: #050690;
        background-color: #ffffff;
        font-size: 14px;
        font-weight: bold;
    }

    </style>
    </head>

    <body>

        <h1 name="top">Turing Machine Language Reference</h1>

        <h2>Basic Structure of TM Instructions:</h2>

            <p>The general language structure of our TM is a 7-element tuple.
                The format of the tuple is 
                <i>READ_TAPE, INITIAL_STATE, READ_TOKEN, WRITE_TOKEN, DIRECTION(S), WRITE_TAPE, END_STATE;.</i>
               The following is an example of a basic instruction tuple:</p>
            <pre>
                t1, A, 0, 1, &lt;, t1, B;
            </pre>
            <p>
                For a better understanding, here is the meaning of each symbol of the initial example.
            </p>
            <pre>
            READ_TAPE&#09;&#09;<b>t1</b>&#09;&nbsp;- Read from Tape 1
            INITIAL_STATE&#09;<b>A</b>&#09;&nbsp;- Start in State A
            READ_TOKEN&#09;&#09;<b>0</b>&#09;&nbsp;- If you read a 0
            WRITE_TOKEN&#09;&#09;<b>1</b>&#09;&nbsp;- Write a 1
            DIRECTION&#09;&#09;<b>&lt;</b>&#09;&nbsp;- Move left
            WRITE_TAPE&#09;&#09;<b>t1</b>&#09;&nbsp;- Write to Tape 1
            END_STATE&#09;&#09;<b>B</b>&#09;&nbsp;- Transition to State B
            </pre>
            
            <h3>Breakdown of Symbols</h3>
            

        <h2><br/>Block Structuring</h2>
        <p>
        Each Karel the Robot instruction must be on a separate line.  A sequence of 
        one or more Karel the Robot instructions that are all indented the same
        number of spaces compose a <strong>block</strong> of code.
        <code>&lt;instruction&gt;</code> refers to any of the five primitive
        instructions above, the conditional branching or iteration instructions below,
        or a user defined instruction.
        </p>
        <pre>
            &lt;instruction&gt;<br />
            &lt;instruction&gt;<br />
              ...<br />
            &lt;instruction&gt;<br />
        </pre>


        <h2><br />Conditional Branching</h2>
        <p>
        <strong>Conditional branching</strong> refers to the ability of a program to
        alter it's <strong>flow of execution</strong> based on the result of the
        evaluation of a <strong>conditional</strong>.  The three types of conditional
        branching instructions in Karel the Robot are <code>if</code> and
        <code>if/else</code> and <code>if/elif/else</code>.
        In the below examples, <code>&lt;test&gt;</code> refers to one of the eighteen conditionals
        we discuss in the next section.
        </p>

        <pre>
            if &lt;test&gt;:<br />
                &lt;block&gt;<br />

        </pre>

        <pre>
            if &lt;test&gt;:<br />
                &lt;block&gt;<br />
            else:<br />
                &lt;block&gt;<br />

        </pre>

        <pre>
            if &lt;test&gt;:<br />
                &lt;block&gt;<br />
            elif &lt;test&gt;:<br />
                &lt;block&gt;<br />
            ...<br />
            elif &lt;test&gt;:<br />
                &lt;block&gt;<br />
            else:<br />
                &lt;block&gt;<br />
        </pre>


        <h2><br />Conditionals</h2>
        <p>
        KtR has eighteen built-in tests that are divided into three groups: the 
        first six are wall tests, the next four are beeper tests, and the last 
        eight are compass tests:
        </p>
            <ol class="list">
            <li>front_is_clear</li>
            <li>front_is_blocked</li>
            <li>left_is_clear</li>
            <li>left_is_blocked</li>
            <li>right_is_clear</li>
            <li>right_is_blocked</li>
            <br />
            <li>next_to_a_beeper</li>
            <li>not_next_to_a_beeper</li>
            <li>any_beepers_in_beeper_bag</li>
            <li>no_beepers_in_beeper_bag</li>
            <br />
            <li>facing_north</li>
            <li>not_facing_north</li>
            <li>facing_south</li>
            <li>not_facing_south</li>
            <li>facing_east</li>
            <li>not_facing_east</li>
            <li>facing_west</li>
            <li>not_facing_west</li>
            </ol>

        <h2><br />Iteration</h2>
        <p>
        <strong>Iteration</strong> refers to the ability of a program to repeat an
        instruction (or block of instructions) over and over until some condition is 
        met. The two types of iteration instructions are the <code>do</code> and <code>while</code> instructions.
        <code>&lt;positive_number&gt;</code> must be an integer greater than 0.
        </p> 

        <pre>
            do &lt;positive_number&gt;:<br />
                &lt;block&gt;<br />
        <br />
        </pre>

        <pre>
            while &lt;test&gt;:<br />
                &lt;block&gt;<br />
        </pre>


        <h2><br />Defining a New Instruction:</h2>
        <p>
        New instructions can be created for Karel the Robot using the 
        <code>def</code> or <code>define</code> statement. <code>&lt;new_name&gt;</code> can
        be any sequence of letters or digits as long as it begins with a letter and is 
        not already used as an instruction. <strong>Letters</strong> for Karel the
        Robot are A..Z, a..z, and "<strong>_</strong>", the underscore character. Karel the Robot is
         case sensitive, so TurnRight, turnright, and turnRight are all different names.
        </p>
        <pre>
            def &lt;new_name&gt;:<br />
                &lt;block&gt;<br />

            <b>OR</b><br/>
            define &lt;new_name&gt;:<br/>
                   &lt;block&gt;<br/>
        </pre>
        <br /><p>Comments are also a useful tool when writing a program, so Karel recognizes
            those as well. Starting a line with <i><b>#</b></i> tells the Karel interpreter to ignore
            the rest of the line.</p>
        <pre>
            <comment># I am a comment</comment>
        </pre>

        <h2><br />Simplest KtR Program</h2>
        <p>
        Execution of a KtR program ends with the <code>turnoff</code> instruction.
         Any program which reaches the end of its instruction sequence without 
        encountering <code>turnoff</code> is considered in error. Thus the simplest
         KtR program is:
        </p>
        <pre>
            turnoff
        </pre>


        <h2><br />An Example Program</h2>
        <p>Given the following world:<br></p>
        <p><img src="images/follow-right-example.png" class="image" alt="Follow right example"></p>

        <p>
        The following program will read the contents of Tape 1, and will determine if it
        is a palindrome or not.
        </p>
        <pre>
            # This example program checks if the input string is a binary palindrome.

            # Input: a string of 0's and 1's, eg '1001001'
            Input: 10101;

            # Machine starts in state 0.
            # State 0: read the leftmost symbol
            t1, 0, 0, _, R, A;
            t1, 0, 1, _, >, A2;
            t1, 0, _, _, *, acceptHalt;


            # State A, A2: find the rightmost symbol
            t1, A, _, _, left, B;
            t1, A, *, *, >, A;

            t1, A2, _, _, <, B2;
            t1, A2, *, *, >, A2;


            # State B, B2: check if the rightmost symbol matches the most recently read left-hand symbol
            t1, B, 0, _, <, C;
            t1, B, _, _, *, acceptHalt;
            t1, B, *, *, *, rejectHalt;

            t1, B2, 1, _, <, C;
            t1, B2, _, _, *, acceptHalt;
            t1, B2, *, *, *, rejectHalt;


            # State C, D: return to left end of remaining input
            t1, C, _, _, *, acceptHalt;
            t1, C, *, *, <, D;

            t1, D, *, *, <, D;
            t1, D, _, _, >, 0;
        </pre>
        
        <footer>
            <p class="copyleft">
                <a href="http://www.gnu.org/copyleft/copyleft.html">
                Copyright</a> &copy; 2017 West Texas A&M University - Computer Science <br/>
                <a href="#top">Back to top</a>
            </p>
        </footer>
    </body>
</html>